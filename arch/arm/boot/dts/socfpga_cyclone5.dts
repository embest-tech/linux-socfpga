/*
 * Copyright Altera Corporation (C) 2012,2014. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/dts-v1/;
/include/ "socfpga.dtsi"

/ {
	model = "Altera SOCFPGA Cyclone V";
	compatible = "altr,socfpga-cyclone5", "altr,socfpga";

	chosen {
		bootargs = "console=ttyS0,115200 root=/dev/mmcblk0p2 rw rootwait";
	};

	memory {
		name = "memory";
		device_type = "memory";
		reg = <0x0 0x40000000>; /* 1 GB */
	};

	aliases {
		/* this allow the ethaddr uboot environmnet variable contents
		 * to be added to the gmac0 device tree blob.
		 */
		ethernet0 = &gmac0;
	};

	soc {
		clkmgr@ffd04000 {
			clocks {
				osc1 {
					clock-frequency = <25000000>;
				};
			};
		};

		dwmmc0@ff704000 {
			num-slots = <1>;
			supports-highspeed;
			broken-cd;
			altr,dw-mshc-ciu-div = <3>;
			altr,dw-mshc-sdr-timing = <0 3>;

			slot@0 {
				cd-gpios = <&gpio1 8 0>;
				reg = <0>;
				bus-width = <4>;
			};
		};

		gpio@ff708000 {
			status = "okay";
		};

		gpio@ff709000 {
			status = "okay";
		};

		gpio@ff70a000 {
			status = "okay";
		};

		i2c0: i2c@ffc04000 {
			speed-mode = <0>;
			status = "okay";
		};

		i2c1: i2c@ffc05000 {
			clock-frequency = <400000>;
			speed-mode = <0>;
			status = "okay";

			at24@50 {
				compatible = "at,24c128";
				pagesize = <64>;
				reg = <0x50>;
			};
		};

		serial0@ffc02000 {
			status = "okay";
		};

		sysmgr@ffd08000 {
			cpu1-start-addr = <0xffd080c4>;
		};

		watchdog0: wd@ffd02000 {
			status = "okay";
		};

	};
};

&i2c0 {
	/*
	 * adjust the falling times to decrease the i2c frequency to 50Khz
	 * because the LCD module does not work at the standard 100Khz
	 */
	i2c-sda-falling-time-ns = <5000>;
	i2c-scl-falling-time-ns = <5000>;

	rtc@68 {
		compatible = "dallas,ds3231";
		reg = <0x68>;
	};
};

&gmac0 {
	phy-mode = "rgmii";
	phy-bus = <0x0>;
	/* phy-addr = <0xffffffff> mean auto probed */
	phy-addr = <0x6>;
	status = "okay";
};

&gmac1 {
	phy-mode = "rgmii";
	phy-bus = <0x1>;
	phy-addr = <0x4>;
	status = "okay";
};

&spi0 {
	status = "okay";
	cs-gpios = <&fpga_extend_io 8 1>;

	spidev@0 {
		compatible = "spidev";
		reg = <0>;      /* chip select */
		spi-max-frequency = <50000000>;
		enable-dma = <1>;
	};
};

&spi1 {
	status = "okay";
	cs-gpios = <&fpga_extend_io 9 1>;

	spidev@0 {
		compatible = "spidev";
		reg = <0>;      /* chip select */
		spi-max-frequency = <50000000>;
		enable-dma = <1>;
	};
};

&dcan1 {
	status = "okay";
};

/{
	soc {
		leds {
			compatible = "gpio-leds";

			user_hps_led9_c {
				label = "user1";
				gpios = <&fpga_extend_io 7 1>;
			};

			user_hps_led8_c {
				label = "user2";
				gpios = <&fpga_extend_io 6 1>;
			};
		};

		gpio_keys {
			compatible = "gpio-keys-polled";
			#address-cells = <1>;
			#size-cells = <0>;
			poll-interval = <50>;
			/* autorepeat; */

			button@0 {
				debounce_interval = <50>;
				wakeup = <1>;
				linux,code = <0x100>;
				label = "pb0_s3";
				gpios = <&gpio2 21 1>;
			};
			button@1 {
				debounce_interval = <50>;
				wakeup = <1>;
				linux,code = <0x101>;
				label = "pb1_s4";
				gpios = <&gpio2 22 1>;
			};
			button@2 {
				debounce_interval = <50>;
				wakeup = <1>;
				linux,code = <0x102>;
				label = "pb2_s5";
				gpios = <&gpio2 23 1>;
			};
			button@3 {
				debounce_interval = <50>;
				wakeup = <1>;
				linux,code = <0x103>;
				label = "pb3_s6";
				gpios = <&gpio2 24 1>;
			};
	
		};

		mmc: dwmmc0@ff704000 {
			pwr-en = <0>;
		};

		hps_0_bridges: bridge@0xc0000000 {
			compatible = "altr,bridge-14.1", "simple-bus";
			reg = < 0xC0000000 0x20000000 
				0xFF200000 0x00200000 >;
			reg-names = "axi_h2f", "axi_h2f_lw";
			#address-cells = < 2 >;
			#size-cells = < 1 >;
			ranges = <
				0x00000001 0x00000040 0xFF200040 0x00000020 
				0x00000001 0x000000E0 0xFF2000E0 0x00000010 
				0x00000001 0x00000138 0xFF200138 0x00000008 
				0x00000001 0x00000200 0xFF200200 0x00000020 
				0x00000001 0x00000220 0xFF200220 0x00000020 
				0x00000001 0x00000020 0xFF200020 0x00000020 
				0x00000001 0x000000D0 0xFF2000D0 0x00000010 
				0x00000001 0x00000130 0xFF200130 0x00000008 
				0x00000001 0x000000A0 0xFF2000A0 0x00000010 
				0x00000001 0x00000170 0xFF200170 0x00000010 >; 

			teds_io: gpio@0x1000000A0 {
				compatible = "ALTR,pio-14.1", "ALTR,pio-1.0", "altr,pio-1.0";
				reg = < 0x00000001 0x000000A0 0x00000010 >;
				width = < 16 >;	/* width type NUMBER */
				resetvalue = < 0 >;	/* embeddedsw.dts.params.resetvalue type NUMBER */
				altr,gpio-bank-width = < 16 >;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
				#gpio-cells = < 2 >;
				gpio-controller;
			}; //end gpio@0x1000000A0 (teds_io)

			fpga_extend_io: gpio@0x100000170 {
				compatible = "ALTR,pio-14.1", "ALTR,pio-1.0", "altr,pio-1.0";
				reg = < 0x00000001 0x00000170 0x00000010 >;
				interrupt-parent = < &intc >;
				interrupts = < 0 49 1 >;
				width = < 10 >;	/* width type NUMBER */
				resetvalue = < 0 >;	/* embeddedsw.dts.params.resetvalue type NUMBER */
				altr,gpio-bank-width = < 10 >;	/* embeddedsw.dts.params.altr,gpio-bank-width type NUMBER */
				altr,interrupt_type = < 3 >;	/* embeddedsw.dts.params.altr,interrupt_type type NUMBER */
				edge_type = < 2 >;	/* embeddedsw.dts.params.edge_type type NUMBER */
				level_trigger = < 0 >;	/* embeddedsw.dts.params.level_trigger type NUMBER */
				#gpio-cells = < 2 >;
				gpio-controller;
			}; //end gpio@0x100000170 (fpga_extend_io)

			msgdma_fpgaddr2hps: msgdma@0x100000040 {
				compatible = "msgdma-mm";
				reg = < 0x00000001 0x00000040 0x00000020 
					0x00000001 0x000000E0 0x00000010 
					0x00000001 0x00000138 0x00000008 
					>;
				reg-names = "csr", "descriptor_slave", "response";
				interrupt-parent = < &intc >;
				interrupts = < 0 45 4 >;
				for-read = < 1 >;
			}; //end msgdma@0x100000040 (msgdma_fpgaddr2hps)

			msgdma_adc2fpgaddr: msgdma@0x100000020 {
				compatible = "msgdma-adc";
				reg = < 0x00000001 0x00000020 0x00000020 
					0x00000001 0x000000D0 0x00000010 
					0x00000001 0x00000130 0x00000008
					0x00000001 0x00000200 0x00000020 
					0x00000001 0x00000220 0x00000020
					>; 
				reg-names = "csr", "descriptor_slave", "response", "adc0", "adc1";
				interrupt-parent = < &intc >;
				interrupts = < 0 46 4
						0 47 4 
						0 48 4
						>;
				fifo_words   = < 0x2000 0x2000 >;
				fifomm_bases = < 0x00000000 0x40000000 >;
				fifomm_sizes = < 0x40000000 0x40000000 >;
				ddrdat_bases = < 0x0000000 0x8000000 >;
				ddrdat_sizes = < 0x8000000 0x8000000 >;
			}; //end msgdma@0x100000020 (msgdma_adc2fpgaddr)

		}; //end bridge@0xc0000000 (hps_0_bridges)
	};
};

